---
id: supplying-arguments
title: Supplying arguments
sidebar_label: Supplying arguments
---

Whenever you define a fixture you can optionally define arguments. By adding arguments to your fixture you can allow consumers to control parts of the output of the fixture.

```typescript
import { fixture } from "fluse";

type UserFixtureArgs = {
  username: string;
};

export const userFixture = fixture({
  create(ctx, args: UserFixtureArgs) {
    const user = new User({ username: args.username });
    return user;
  },
});
```

In the example above we are allowing consumers to pass in a username for the created user. We do this by using the second argument of the `create` function. For type-safety we created a type for the arguments `UserFixtureArgs`.

Whenever the fixture is used now it will require additional arguments to be passed in.

```typescript
import { createExecutor } from "fluse";

const execute = createExecutor();
const result = await execute(
  userFixture("testUser", { args: { username: "test" } })
);
```

Notice how we pass in a username, as defined by our `UserFixtureArgs` type. If you are working in TypeScript Fluse will provide you with type information and in this case even complain if you try to use the fixture without passing in a username.

Supplying arguments can be very useful for controlling certain parts of a fixture, it is also a vital piece to enable you to [combine fixtures](./combining-fixtures.md).

## Passing fixtures as arguments

You may also pass single fixtures as an argument:

```typescript
import { createExecutor, fixture } from "fluse";
import { Comment } from "./enttiies/Comment";
import { Post } from "./entitites/Post";

export const commentFixture = fixture({
  create(ctx) {
    const comment = new Comment({ message: "bar" });
    return comment;
  },
});

type PostFixtureArgs = {
  comments: Comment[];
};

export const postFixture = fixture({
  create(ctx, args: PostFixtureArgs) {
    const post = new Post({
      title: "foo",
      comments: args.comments,
    });
    return post;
  },
});

const execute = createExecutor();
const result = await execute(
  postFixture("testPost", {
    args: { comments: commentFixture.asArg({ list: 10 }) },
  })
);
```

In the above example the `postFixture` accepts an argument for `comments`. Since we already have a fixture for a single `comment` we can use this fixture as a input argument for the `postFixture`.

:::tip
Passing fixtures as arguments is useful for nested structures. Note that when passing fixtures as arguments a `name` is not required and thus there won't be a named key on the result. In order to access the data generated by this fixture you have to reach into your nested structure yourself (in this case the comments are only available via `result.testPost.comments`).
:::
